// Generated by CoffeeScript 1.8.0
var beget, comparisonNameToOperatorMapping, explodeObject, factories, identity, isEmptyArray, isNegation, isRawSqlFragment, mainFactory, modifierFactories, name, operator, prototypes, some, subqueryNameToOperatorMapping, _fn, _fn1,
  __slice = [].slice;

beget = function(proto, properties) {
  var key, object, value, _fn;
  object = Object.create(proto);
  if (properties != null) {
    _fn = function(key, value) {
      return object[key] = value;
    };
    for (key in properties) {
      value = properties[key];
      _fn(key, value);
    }
  }
  return object;
};

explodeObject = function(arrayOrObject) {
  var array, key, value, _fn;
  if (Array.isArray(arrayOrObject)) {
    return arrayOrObject;
  }
  array = [];
  _fn = function(key, value) {
    var object;
    object = {};
    object[key] = value;
    return array.push(object);
  };
  for (key in arrayOrObject) {
    value = arrayOrObject[key];
    _fn(key, value);
  }
  return array;
};

identity = function(x) {
  return x;
};

isEmptyArray = function(x) {
  return Array.isArray(x) && x.length === 0;
};

some = function(array, iterator, predicate, sentinel) {
  var i, length, result;
  if (iterator == null) {
    iterator = identity;
  }
  if (predicate == null) {
    predicate = function(x) {
      return x != null;
    };
  }
  if (sentinel == null) {
    sentinel = void 0;
  }
  i = 0;
  length = array.length;
  while (i < length) {
    result = iterator(array[i], i);
    if (predicate(result, i)) {
      return result;
    }
    i++;
  }
  return sentinel;
};

prototypes = {};

factories = {};

modifierFactories = {};

prototypes.base = {
  not: function() {
    return factories.not(this);
  },
  and: function(other) {
    return factories.and([this, other]);
  },
  or: function(other) {
    return factories.or([this, other]);
  }
};

isRawSqlFragment = function(value) {
  return (value != null) && 'function' === typeof value.sql;
};

prototypes.raw = beget(prototypes.base, {
  sql: function() {
    var i, params;
    if (!this._params) {
      return this._sql;
    }
    i = -1;
    params = this._params;
    return this._sql.replace(/\?/g, function() {
      i++;
      if (Array.isArray(params[i])) {
        return (params[i].map(function() {
          return "?";
        })).join(", ");
      } else {
        return "?";
      }
    });
  },
  params: function() {
    var _ref;
    if (this._params) {
      return (_ref = []).concat.apply(_ref, this._params);
    }
  }
});

factories.raw = function(sql, params) {
  return beget(prototypes.raw, {
    _sql: sql,
    _params: params
  });
};

prototypes.comparison = beget(prototypes.base, {
  sql: function(escape) {
    if (escape == null) {
      escape = identity;
    }
    if (isRawSqlFragment(this._value)) {
      return "" + (escape(this._key)) + " " + this._operator + " (" + (this._value.sql()) + ")";
    } else {
      return "" + (escape(this._key)) + " " + this._operator + " ?";
    }
  },
  params: function() {
    var _base;
    if (isRawSqlFragment(this._value)) {
      return (typeof (_base = this._value).params === "function" ? _base.params() : void 0) || [];
    } else {
      return [this._value];
    }
  }
});

comparisonNameToOperatorMapping = {
  $eq: '=',
  $ne: '!=',
  $lt: '<',
  $lte: '<=',
  $gt: '>',
  $gte: '>='
};

_fn = function(name, operator) {
  return modifierFactories[name] = function(key, value) {
    return beget(prototypes.comparison, {
      _key: key,
      _value: value,
      _operator: operator
    });
  };
};
for (name in comparisonNameToOperatorMapping) {
  operator = comparisonNameToOperatorMapping[name];
  _fn(name, operator);
}

prototypes["null"] = beget(prototypes.base, {
  sql: function(escape) {
    if (escape == null) {
      escape = identity;
    }
    return "" + (escape(this._key)) + " IS " + (this._isNull ? '' : 'NOT ') + "NULL";
  },
  params: function() {
    return [];
  }
});

modifierFactories.$null = function(k, isNull) {
  return beget(prototypes["null"], {
    _key: k,
    _isNull: isNull
  });
};

prototypes.not = beget(prototypes.base, {
  innerCriterion: function() {
    return this._criterion._criterion;
  },
  sql: function(escape) {
    if (escape == null) {
      escape = identity;
    }
    if (isNegation(this._criterion)) {
      return this.innerCriterion().sql(escape);
    } else {
      return "NOT (" + (this._criterion.sql(escape)) + ")";
    }
  },
  params: function() {
    return this._criterion.params();
  }
});

isNegation = function(c) {
  return prototypes.not.isPrototypeOf(c);
};

factories.not = function(criterion) {
  return beget(prototypes.not, {
    _criterion: criterion
  });
};

prototypes.exists = beget(prototypes.base, {
  sql: function(escape) {
    if (escape == null) {
      escape = identity;
    }
    return "EXISTS (" + (this._value.sql(escape)) + ")";
  },
  params: function() {
    var _base;
    return (typeof (_base = this._value).params === "function" ? _base.params() : void 0) || [];
  }
});

factories.exists = function(value) {
  if (!isRawSqlFragment(value)) {
    throw new Error('$exists key requires sql-fragment value');
  }
  return beget(prototypes.exists, {
    _value: value
  });
};

prototypes.subquery = beget(prototypes.base, {
  sql: function(escape) {
    var questionMarks;
    if (escape == null) {
      escape = identity;
    }
    if (isRawSqlFragment(this._value)) {
      return "" + (escape(this._key)) + " " + this._operator + " (" + (this._value.sql(escape)) + ")";
    } else {
      questionMarks = [];
      this._value.forEach(function() {
        return questionMarks.push('?');
      });
      return "" + (escape(this._key)) + " " + this._operator + " (" + (questionMarks.join(', ')) + ")";
    }
  },
  params: function() {
    var _base;
    if (isRawSqlFragment(this._value)) {
      return (typeof (_base = this._value).params === "function" ? _base.params() : void 0) || [];
    } else {
      return this._value;
    }
  }
});

subqueryNameToOperatorMapping = {
  $in: 'IN',
  $nin: 'NOT IN',
  $any: '= ANY',
  $neAny: '!= ANY',
  $ltAny: '< ANY',
  $lteAny: '<= ANY',
  $gtAny: '> ANY',
  $gteAny: '>= ANY',
  $all: '= ALL',
  $neAll: '!= ALL',
  $ltAll: '< ALL',
  $lteAll: '<= ALL',
  $gtAll: '> ALL',
  $gteAll: '>= ALL'
};

_fn1 = function(name, operator) {
  return modifierFactories[name] = function(key, value) {
    if (Array.isArray(value)) {
      if (name === '$in' || name === '$nin') {
        if (value.length === 0) {
          throw new Error("" + name + " key with empty array value");
        }
      } else {
        throw new Error("" + name + " key doesn't support array value. only $in and $nin do!");
      }
    } else {
      if (!isRawSqlFragment(value)) {
        throw new Error("" + name + " key requires sql-fragment value (or array in case of $in and $nin)");
      }
    }
    return beget(prototypes.subquery, {
      _key: key,
      _value: value,
      _operator: operator
    });
  };
};
for (name in subqueryNameToOperatorMapping) {
  operator = subqueryNameToOperatorMapping[name];
  _fn1(name, operator);
}

prototypes.combination = beget(prototypes.base, {
  sql: function(escape) {
    var parts;
    if (escape == null) {
      escape = identity;
    }
    parts = this._criteria.map(function(c) {
      return "(" + (c.sql(escape)) + ")";
    });
    return parts.join(" " + this._operator + " ");
  },
  params: function() {
    var params;
    params = [];
    this._criteria.forEach(function(c) {
      return params = params.concat(c.params());
    });
    return params;
  }
});

factories.and = function(criteria) {
  return beget(prototypes.combination, {
    _criteria: criteria,
    _operator: 'AND'
  });
};

factories.or = function(criteria) {
  return beget(prototypes.combination, {
    _criteria: criteria,
    _operator: 'OR'
  });
};

module.exports = mainFactory = function() {
  var emptyArrayParam, first, hasModifier, innerValue, key, keyCount, keys, modifier, modifierFactory, rest, type, value;
  first = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  type = typeof first;
  if (!('string' === type || 'object' === type)) {
    throw new Error("string or object expected as first argument but " + type + " given");
  }
  if (type === 'string') {
    emptyArrayParam = some(rest, function(x, i) {
      return {
        x: x,
        i: i
      };
    }, function(_arg) {
      var i, x;
      x = _arg.x, i = _arg.i;
      return isEmptyArray(x);
    });
    if (emptyArrayParam != null) {
      throw new Error("params[" + emptyArrayParam.i + "] is an empty array");
    }
    return factories.raw(first, rest);
  }
  if (Array.isArray(first)) {
    if (first.length === 0) {
      throw new Error('empty query object');
    }
    return factories.and(first.map(mainFactory));
  }
  keyCount = Object.keys(first).length;
  if (0 === keyCount) {
    throw new Error('empty query object');
  }
  if (keyCount > 1) {
    return factories.and(explodeObject(first).map(mainFactory));
  }
  key = Object.keys(first)[0];
  value = first[key];
  if (value == null) {
    throw new Error("value undefined or null for key " + key);
  }
  if (key === '$or') {
    return factories.or(explodeObject(value).map(mainFactory));
  }
  if (key === '$not') {
    return factories.not(mainFactory(value));
  }
  if (key === '$exists') {
    return factories.exists(value);
  }
  if ('object' !== typeof value) {
    return modifierFactories.$eq(key, value);
  }
  if (Array.isArray(value)) {
    return modifierFactories.$in(key, value);
  }
  keys = Object.keys(value);
  modifier = keys[0];
  hasModifier = keys.length === 1 && 0 === modifier.indexOf('$');
  if (!hasModifier) {
    return modifierFactories.$eq(key, value);
  }
  innerValue = value[modifier];
  if (innerValue == null) {
    throw new Error("value undefined or null for key " + key + " and modifier key " + modifier);
  }
  modifierFactory = modifierFactories[modifier];
  if (modifierFactory != null) {
    return modifierFactory(key, innerValue);
  }
  throw new Error("unknown modifier key " + modifier);
};
